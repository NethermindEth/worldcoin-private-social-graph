import vote_circuit from '../../circuits/votePour/target/votePour.json';
import claim_circuit from '../../circuits/claimPour/target/claimPour.json';
import { BarretenbergBackend, BarretenbergVerifier as Verifier } from '@noir-lang/backend_barretenberg';
import { CompiledCircuit, InputMap, Noir, ProofData } from '@noir-lang/noir_js';

/**
 * 
 * @param inputs - public and private inputs used in vote circuit
 * @returns the proofData generated by executing the circuit- the proof itself and the public values
 * 
 * @description will generate the proof of the vote circuit and will verify it. It will returnt the proof to be
 *              verified again in a different function
 */
export async function proveVote(inputs: InputMap) {
    try {
        const backend = new BarretenbergBackend(vote_circuit as CompiledCircuit);
        const noir = new Noir(vote_circuit as CompiledCircuit, backend);
        const proof = await noir.generateProof(inputs);

        const verificationKey = await backend.getVerificationKey();
        const verifier = new Verifier();
        const isValid = await verifier.verifyProof(proof, verificationKey);
        return proof;
    } catch (error) {
        console.log(error);
        throw new Error();
    }
}

/**
 * 
 * @param proof - the proof data returned in the proveVote function to be verified
 * @returns true/false -> whether the proof data corresponds to the circuit and is valid
 */
export async function verifyVote(proof: ProofData) {
    const backend = new BarretenbergBackend(vote_circuit as CompiledCircuit);
    const noir = new Noir(vote_circuit as CompiledCircuit, backend);
    const verificationKey = await backend.getVerificationKey();
    const verifier = new Verifier();
    const isValid = await verifier.verifyProof(proof, verificationKey);
    return isValid;
}

/**
 * 
 * @param inputs - public and private inputs used in claim circuit
 * @returns the proofData generated by executing the circuit- the proof itself and the public values
 * 
 * @description will generate the proof of the claim circuit and will verify it. It will returnt the proof to be
 *              verified again in a different function
 */
export async function proveClaim(inputs: InputMap) {
    try {
        const backend = new BarretenbergBackend(claim_circuit as CompiledCircuit);
        const noir = new Noir(claim_circuit as CompiledCircuit, backend);
        const proof = await noir.generateProof(inputs);

        const verificationKey = await backend.getVerificationKey();
        const verifier = new Verifier();
        const isValid = await verifier.verifyProof(proof, verificationKey);
        return proof;
    } catch (error) {
        throw new Error();
    }
}

/**
 * 
 * @param proof - the proof data returned in the proveVote function to be verified
 * @returns true/false -> whether the proof data corresponds to the circuit and is valid
 */
export async function verifyClaim(proof: ProofData) {
    const backend = new BarretenbergBackend(claim_circuit as CompiledCircuit);
    const noir = new Noir(claim_circuit as CompiledCircuit, backend);
    const verificationKey = await backend.getVerificationKey();
    const verifier = new Verifier();
    const isValid = await verifier.verifyProof(proof, verificationKey);
    return isValid;
}
